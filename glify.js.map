{"version":3,"sources":["map-matrix.ts","leaflet-bindings.js","canvas-overlay.ts","base.ts","color.ts","line-feature-vertices.ts","utils.ts","lines.ts","points.ts","shapes.ts","index.ts"],"names":["exports","L","window","module"],"mappings":";AAAa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAb,IAAA,EAAA,WAEE,SAAA,IACO,KAAA,MAAQ,IAAI,aAAa,IA+BlC,OA7BE,EAAA,UAAA,IAAA,SAAI,EAA0B,GAErB,OADF,KAAA,MAAM,IAAI,EAAO,GACf,MAET,EAAA,UAAA,gBAAA,SAAgB,EAAY,GAClB,IAAA,EAAA,KAAA,MAOD,OALP,EAAM,KAAO,EAAM,GAAK,EAAK,EAAM,GAAK,EACxC,EAAM,KAAO,EAAM,GAAK,EAAK,EAAM,GAAK,EACxC,EAAM,KAAO,EAAM,GAAK,EAAK,EAAM,GAAK,EACxC,EAAM,KAAO,EAAM,GAAK,EAAK,EAAM,GAAK,EAEjC,MAET,EAAA,UAAA,YAAA,SAAY,GACF,IAAA,EAAA,KAAA,MAYD,OAVP,EAAM,IAAM,EACZ,EAAM,IAAM,EACZ,EAAM,IAAM,EACZ,EAAM,IAAM,EAEZ,EAAM,IAAM,EACZ,EAAM,IAAM,EACZ,EAAM,IAAM,EACZ,EAAM,IAAM,EAEL,MAEX,EAlCA,GAAa,QAAA,UAAA;;ACab,aARA,IAAA,EAAA,EAAA,QAAA,YAQA,SAAA,IAAA,GAAA,mBAAA,QAAA,OAAA,KAAA,IAAA,EAAA,IAAA,QAAA,OAAA,EAAA,WAAA,OAAA,GAAA,EAAA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,GAAA,OAAA,GAAA,iBAAA,GAAA,mBAAA,EAAA,MAAA,CAAA,QAAA,GAAA,IAAA,EAAA,IAAA,GAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,KAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EANA,IAAIA,EAAUC,EAEVC,QAAUA,OAAOD,IACnBD,EAAUE,OAAOD,GAGnBE,OAAOH,QAAUA;;ACyBJ,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,EAAA,eAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA3Bb,IAAA,EAAA,QAAA,sBA2BA,EAAA,SAAA,GAQE,SAAA,EACE,GADF,IAAA,EAGE,EAAA,KAAA,OAAO,KAXE,OAYT,EAAK,cAAgB,EACrB,EAAK,OAAS,KACd,EAAK,iBAAmB,GAdf,EA8Kb,OA9KmC,EAAA,EAAA,GAiBjC,EAAA,UAAA,QAAA,SAAQ,GAEC,OADF,KAAA,cAAgB,EACd,MAGT,EAAA,UAAA,OAAA,SAAO,GAEE,OADP,EAAA,KAAK,WAAW,KAAM,GACf,MAGT,EAAA,UAAA,OAAA,SAAO,GAOE,MANiB,mBAAb,GACJ,KAAA,iBAAiB,KAAK,GAET,OAAhB,KAAK,SACF,KAAA,OAAS,EAAA,KAAK,iBAAiB,KAAK,QAAS,OAE7C,MAGT,EAAA,UAAA,MAAA,SAAM,GACC,KAAA,KAAO,EACP,KAAA,OAAS,KAAK,QAAU,SAAS,cAAc,UAE9C,IAAA,EAAO,EAAI,UACb,EAAW,EAAI,QAAQ,eAAiB,EAAA,QAAQ,MAkB7C,OAfF,KAAA,OAAO,MAAQ,EAAK,EACpB,KAAA,OAAO,OAAS,EAAK,EAErB,KAAA,OAAO,UAAY,iBAAmB,EAAW,WAAa,QAEnE,EAAI,OAAO,YAAY,YAAY,KAAK,QAExC,EAAI,GAAG,UAAW,KAAK,OAAQ,MAC/B,EAAI,GAAG,SAAW,KAAK,QAAS,MAE5B,GACF,EAAI,GAAG,WAAY,EAAA,MAAQ,KAAK,aAAe,KAAK,oBAAqB,MAGtE,KAAA,SACE,MAGT,EAAA,UAAA,SAAA,SAAS,GASA,OARP,EAAI,WAAW,YAAY,YAAY,KAAK,QAE5C,EAAI,IAAI,UAAW,KAAK,OAAQ,MAChC,EAAI,IAAI,SAAU,KAAK,QAAS,MAE5B,EAAI,QAAQ,eAAiB,EAAA,QAAQ,OACvC,EAAI,IAAI,WAAY,EAAA,MAAQ,KAAK,aAAe,KAAK,oBAAqB,MAErE,MAGT,EAAA,UAAA,MAAA,SAAM,GAEG,OADP,EAAI,SAAS,MACN,MAGT,EAAA,UAAA,QAAA,SAAQ,GACD,KAAA,OAAO,MAAS,EAAY,QAAQ,EACpC,KAAA,OAAO,OAAS,EAAY,QAAQ,GAG3C,EAAA,UAAA,OAAA,WACQ,IAAA,EAAU,KAAK,KAAK,2BAA2B,CAAC,EAAG,IACzD,EAAA,QAAQ,YAAY,KAAK,OAAQ,GAC5B,KAAA,WAGP,EAAA,UAAA,QAAA,WACQ,IAAE,EAAF,KAAE,KAAM,EAAR,KAAQ,OACV,EAAO,EAAK,UACZ,EAAS,EAAK,YACd,EAAsB,IAAT,EAAK,GAAY,aAAgB,EAAO,UAAY,EAAO,YACxE,EAAO,EAAK,UACZ,EAAU,IAAI,EAAA,OAAO,EAAO,WAAY,EAAO,WAC/C,EAAS,KAAK,kBAAkB,EAAS,GAetC,IAZH,KAAK,eACF,KAAA,cAAc,CACjB,OAAM,EACN,OAAM,EACN,OAAM,EACN,MAAO,KAAK,IAAI,EAAG,GACnB,KAAI,EACJ,UAAS,EACT,KAAI,IAID,KAAK,iBAAiB,OAAS,GAC/B,KAAA,iBAAiB,OAAjB,CAAyB,MAG3B,KAAA,OAAS,MAGhB,EAAA,UAAA,aAAA,SAAa,GACH,IAAA,EAAA,KAAA,KACJ,EAAQ,EAAK,aAAa,EAAE,KAAM,EAAK,WAEvC,EAAS,KAAK,uCAAuC,EAAK,YAAa,EAAE,KAAM,EAAE,QAAQ,IAE7F,EAAA,QAAQ,aAAa,KAAK,OAAQ,EAAQ,IAG5C,EAAA,UAAA,oBAAA,SAAoB,GACV,IAAA,EAAA,KAAA,KACJ,EAAQ,EAAK,aAAa,EAAE,KAAM,EAAK,WAEvC,EAAS,EAAK,iBAAiB,EAAE,QAChC,aAAa,GAEb,SAAS,EAAK,kBAEnB,EAAA,QAAQ,aAAa,KAAK,OAAQ,EAAQ,IAG5C,EAAA,UAAA,kBAAA,SAAkB,EAAgB,GAGxB,IAAA,EAAA,KAAA,KAAA,QAAA,IAEF,EAAA,EAAA,WAAA,EACF,EAAI,KAAK,GAAK,IACd,EAAM,EAAO,IACb,EAAM,KAAK,IAAI,EAAM,GACrB,EAAiB,IAAI,EAAA,MAEnB,EAAI,EAAO,IAAM,EAEjB,EAAI,KAAK,KAAK,EAAI,IAAQ,EAAI,IAAQ,GAExC,EAAQ,EAAI,MAAM,GAGf,OAAA,EAAI,eAAe,WAAW,EAAgB,IAGvD,EAAA,UAAA,uCAAA,SAAuC,EAA4B,EAAc,GAIzE,IAAA,EAAU,KAAK,KAAK,mBAAmB,EAAQ,GAC9C,OAAA,IAAI,EAAA,OAAO,CAChB,KAAK,kBAAkB,EAAa,eAAgB,GAAM,SAAS,GACnE,KAAK,kBAAkB,EAAa,eAAgB,GAAM,SAAS,GACnE,KAAK,kBAAkB,EAAa,eAAgB,GAAM,SAAS,GACnE,KAAK,kBAAkB,EAAa,eAAgB,GAAM,SAAS,MAGzE,EA9KA,CAAmC,EAAA,OAAtB,QAAA,cAAA;;ACNS,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA9BtB,IAAA,EAAA,QAAA,gBACA,EAAA,QAAA,oBA6BA,EAAA,WAgBE,SAAA,EAAY,GAAZ,IAAA,EAAA,KACO,KAAA,oBAAsB,IAAI,aAAa,IACvC,KAAA,UAAY,IAAI,EAAA,UAChB,KAAA,QAAS,EACT,KAAA,aAAe,KACf,KAAA,eAAiB,KACjB,KAAA,QAAU,KACV,KAAA,OAAS,KACT,KAAA,SAAW,KACV,IAAA,EAAwB,QAAQ,EAAS,uBACzC,EAAQ,KAAK,MAAQ,IAAI,EAAA,cAAc,SAAC,GAAY,OAAA,EAAK,aAAa,KACzE,MAAM,EAAS,KACZ,EAAS,KAAK,OAAS,EAAM,OACnC,EAAO,MAAQ,EAAO,YACtB,EAAO,OAAS,EAAO,aACvB,EAAO,MAAM,SAAW,WACpB,EAAS,YACX,EAAO,WAAa,IAAM,EAAS,WAEhC,KAAA,GACH,EAAO,WAAW,SAAU,CAAE,sBAAqB,KAChD,EAAO,WAAW,QAAS,CAAE,sBAAqB,KAClD,EAAO,WAAW,qBAAsB,CAAE,sBAAqB,IAiHxE,OA5GE,EAAA,UAAA,sBAAA,SAAsB,GAChB,IAAC,KAAK,SAAS,gBACV,OAAA,KAEH,IAEE,EAAF,KAAE,GAAI,EAAN,KAAM,QACJ,EAAA,KAAA,SAAA,gBACH,IAAA,IAAM,KAAQ,EACb,GAAC,EAAgB,eAAe,GAAhC,CACE,IAAA,EAAiB,EAAgB,GACjC,EAAM,EAAG,kBAAkB,EAAS,GACtC,GAAA,EAAM,EACF,MAAA,IAAI,MAAM,mBAAqB,EAAO,cAE9C,EAAG,oBACD,EACA,EAAe,KACf,EAAG,EAAe,QAChB,EAAe,UACjB,GAAa,EAAe,OAhBlB,GAiBV,EAAY,EAAe,OAC7B,EAAG,wBAAwB,GAGtB,OAAA,MAGT,EAAA,UAAA,QAAA,SAAQ,GAEC,OADF,KAAA,SAAS,KAAO,EACd,MAGT,EAAA,UAAA,MAAA,WACQ,IAAA,EAAW,KAAK,SAKf,OAJH,EAAS,OACX,EAAS,WAAW,EAAS,KAGxB,KACJ,oBACA,sBACA,gBAGL,EAAA,UAAA,kBAAA,WACQ,IAAA,EAAK,KAAK,GACZ,EAAW,KAAK,SAChB,EAA4D,mBAAhC,EAAS,mBACjC,EAAS,qBACT,EAAS,mBACb,EAAe,EAAG,aAAa,EAAG,eAQ/B,OALP,EAAG,aAAa,EAAc,GAC9B,EAAG,cAAc,GAEZ,KAAA,aAAe,EAEb,MAGT,EAAA,UAAA,oBAAA,WACQ,IAAA,EAAK,KAAK,GACZ,EAAW,KAAK,SAChB,EAAgE,mBAAlC,EAAS,qBACnC,EAAS,uBACT,EAAS,qBACb,EAAiB,EAAG,aAAa,EAAG,iBAQjC,OALP,EAAG,aAAa,EAAgB,GAChC,EAAG,cAAc,GAEZ,KAAA,eAAiB,EAEf,MAGT,EAAA,UAAA,aAAA,WAEQ,IAAA,EAAK,KAAK,GACZ,EAAU,EAAG,gBAYV,OATP,EAAG,aAAa,EAAS,KAAK,cAC9B,EAAG,aAAa,EAAS,KAAK,gBAC9B,EAAG,YAAY,GACf,EAAG,WAAW,GACd,EAAG,UAAU,EAAG,UAAW,EAAG,qBAC9B,EAAG,OAAO,EAAG,OAER,KAAA,QAAU,EAER,MAGT,EAAA,UAAA,MAAA,SAAM,GAGG,OAFF,KAAA,MAAM,MAAM,GAAO,KAAK,SAAS,KACjC,KAAA,QAAS,EACP,KAAK,UAGd,EAAA,UAAA,OAAA,WAGS,OAFF,KAAA,SAAS,IAAI,YAAY,KAAK,OAC9B,KAAA,QAAS,EACP,MAEX,EAvJA,GAAsB,QAAA,KAAA;;ACfT,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAXb,IAAM,EAAgB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChC,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9B,EAAe,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/B,EAAe,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/B,EAAiB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAEjC,EAAgB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChC,EAAgB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAEhC,EAAe,CAAC,EAAG,GAAK,EAAG,GAAK,EAAG,IAEzC,EAAA,WAAA,SAAA,KAkDA,OAzCE,OAAA,eAAW,EAAA,OAAI,CAAf,IAAA,WACS,OAAA,GADM,YAAA,EATJ,cAAA,IAaJ,EAAA,QAAP,SAAe,GACT,OAAA,EAAI,OAAS,EAAU,MAGZ,OAFf,EAAM,EAAI,eAEF,KACN,EAAM,EAAI,UAAU,EAAG,EAAI,SAOtB,CAAE,EAJC,SAAS,EAAI,GAAK,EAAI,GAAI,IAIpB,IAAK,EAHb,SAAS,EAAI,GAAK,EAAI,GAAI,IAGN,IAAK,EAFzB,SAAS,EAAI,GAAK,EAAI,GAAI,IAEM,OAGnC,EAAA,OAAP,WACS,MAAA,CACL,EAAG,KAAK,SACR,EAAG,KAAK,SACR,EAAG,KAAK,WAIL,EAAA,OAAP,WACU,OAAA,KAAK,MAAsB,EAAhB,KAAK,WACjB,KAAA,EACI,OAAA,EACJ,KAAA,EACI,OAAA,EACJ,KAAA,EACI,OAAA,EACJ,KAAA,EACI,OAAA,EACJ,KAAA,EACI,OAAA,IAGf,EAlDA,GAAa,QAAA,MAAA;;ACNA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAXb,IAAA,EAAA,QAAA,sBAWA,EAAA,WASE,SAAA,EAAY,GACV,OAAO,OAAO,KAAM,GACf,KAAA,YAAc,EACd,KAAA,MAAQ,GACR,KAAA,OAAS,EA2BlB,OAxBE,EAAA,UAAA,oBAAA,SAAoB,GAEb,IADG,IAAA,EAAA,KAAA,MACC,EAAI,EAAG,EAAI,EAAY,OAAQ,IAClC,GAAA,MAAM,QAAQ,EAAY,GAAG,IAC1B,KAAA,oBAAoB,EAAY,QADnC,CAIE,IAAA,EAAQ,KAAK,QACjB,IAAI,EAAA,OACF,EAAY,GAAG,KAAK,aACpB,EAAY,GAAG,KAAK,eACnB,GACA,KAAA,KAAK,EAAM,EAAG,EAAM,EAAG,EAAM,EAAG,EAAM,EAAG,EAAM,GAC1C,IAAN,GAAW,IAAM,EAAY,OAAS,IACnC,KAAA,aAAe,GAEjB,KAAA,aAAe,IAIxB,EAAA,UAAA,KAAA,WAAK,IApCM,IAAA,EAoCN,EAAA,GAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,EAAA,GAAA,UAAA,IACH,EAAA,KAAK,OAAM,KAAI,MAAA,EAAI,GACd,KAAA,OAAS,KAAK,MAAM,QAE7B,EAxCA,GAAa,QAAA,oBAAA;;AC8Db,aAvEA,SAAgB,EAAS,EAAc,GAC/B,IAAA,EAAW,GAEZ,IAAA,IAAM,KAAK,EACT,EAAS,eAAe,KAC7B,EAAS,GAAM,EAAa,eAAe,GAAK,EAAa,GAAK,EAAS,IAGtE,OAAA,EAKT,SAAgB,EAAc,EAAU,GAChC,IAAA,EAAQ,KAAK,GAAK,IACtB,EAAgB,EAAV,KAAK,GACX,EAAc,KAAK,IAAI,EAAW,GAI7B,MAAA,CAAC,GAFK,EAAY,KAAO,IAAO,IAEpB,EAH0D,KAAjE,GAAM,KAAK,KAAK,EAAI,IAAgB,EAAI,IAAiB,IAMvE,SAAgB,EAAc,EAAa,EAAY,GAE9C,OADkB,EAAY,EAAI,EAAW,IAAM,EAAY,EAAI,EAAW,IAAM,EAAY,EAAI,EAAW,IAAM,EAAY,EAAI,EAAW,IAC7H,EAAS,EAGrC,SAAgB,EAAU,EAAG,EAAG,EAAI,EAAI,EAAI,GACpC,IAWF,EAAI,EATF,EAAI,EAAK,EACT,EAAI,EAAK,EAGT,EAAS,EAAI,EAAI,EAAI,EACvB,GAAS,EACE,IAAX,IACF,IATQ,EAAI,GAKE,GAJN,EAAI,GAIU,GAIR,GAIZ,EAAQ,GACV,EAAK,EACL,EAAK,GACI,EAAQ,GACjB,EAAK,EACL,EAAK,IAEL,EAAK,EAAK,EAAQ,EAClB,EAAK,EAAK,EAAQ,GAGhB,IAAA,EAAK,EAAI,EACT,EAAK,EAAI,EACN,OAAA,KAAK,KAAK,EAAK,EAAK,EAAK,GAGlC,SAAgB,EAAe,EAAY,GAClC,OAAA,KAAK,KAAK,EAAK,EAAK,EAAK,GAGlC,SAAgB,EAAiB,EAAmB,EAAmB,GAC/D,IAAA,EAAS,EAAI,mBAAmB,GAClC,EAAS,EAAI,mBAAmB,GAI7B,OAAA,EAHE,EAAO,EAAI,EAAO,EAClB,EAAO,EAAI,EAAO,GAK7B,SAAgB,EAAW,GACnB,IAAA,EAAK,SAAS,cAAc,OAC9B,EAAI,EAAG,MACP,EAAI,EAAe,EACnB,EAAI,EAAe,EAGvB,EAAE,KAAO,EAAI,KACb,EAAE,IAAM,EAAI,KACZ,EAAE,MAAQ,OACV,EAAE,OAAS,OACX,EAAE,SAAW,WACb,EAAE,gBAAkB,KAAuB,SAAhB,KAAK,UAAuB,GAAG,SAAS,IAEnE,SAAS,KAAK,YAAY,GAd5B,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAvEA,QAAA,SAAA,EAaA,QAAA,cAAA,EAUA,QAAA,cAAA,EAKA,QAAA,UAAA,EA8BA,QAAA,eAAA,EAIA,QAAA,iBAAA,EASA,QAAA,WAAA;;ACxCa,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,EAAA,eAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAjCb,IAAA,EAAA,QAAA,UAEA,EAAA,QAAA,WAEA,EAAA,QAAA,2BACA,EAAA,QAAA,WAMM,EAA2B,CAC/B,IAAK,KACL,KAAM,GACN,aAAc,KACd,YAAa,KACb,WAAY,KACZ,mBAAoB,KACpB,qBAAsB,KACtB,MAAO,KACP,MAAO,EAAA,MAAM,OACb,UAAW,GACX,QAAS,GACT,OAAQ,EACR,gBAAiB,CACf,MAAO,CACL,KAAM,QACN,MAAO,EACP,KAAM,KAKZ,EAAA,SAAA,GAQE,SAAA,EAAY,GAAZ,IAAA,EACE,EAAA,KAAA,KAAM,IAAS,KAIX,GAHJ,EAAM,UAAU,KAAK,GACrB,EAAK,SAAQ,EAAA,EAAA,GAAQ,EAAM,UAAa,IAEnC,EAAS,KAAM,MAAM,IAAI,MAAM,mCAChC,IAAC,EAAS,IAAK,MAAM,IAAI,MAAM,2CAd1B,OAgBT,EAAK,QAAS,EACd,EAAK,YAAc,GAEnB,EACG,QACA,SArBM,EAsPb,OAtP2B,EAAA,EAAA,GAwBzB,EAAA,UAAA,OAAA,WACO,KAAA,gBAEC,IAAA,EAAsB,KAAK,oBAC7B,EAAW,KAAK,SAChB,EAAA,KAAE,EAAA,EAAA,OAAQ,EAAA,EAAA,GAAI,EAAA,EAAA,MAAO,EAAA,EAAA,SAAU,EAAA,EAAA,QAC/B,EAAe,EAAG,eAClB,EAAS,EAAG,kBAAkB,EAAS,UACvC,EAAU,EAAG,mBAAmB,EAAS,WAG7C,EAAG,UAAU,EAAS,EAAS,SAC/B,EAAG,WAAW,EAAG,aAAc,GAY1B,IAFD,IAAA,EAAO,EAAS,OACd,EAAc,GACX,EAAI,EAAG,EAAI,EAAM,IAGnB,IAFC,IAAA,EAAc,EAAS,GAAG,MAC1B,EAAS,EAAY,OAAS,EAC3B,EAAI,EAAG,EAAI,EAAQ,IAAK,CACzB,IAAA,EAAkB,EAAJ,EACV,IAAN,GAAW,IAAO,EAAS,GAC7B,EAAY,KACV,EAAY,GACZ,EAAY,EAAc,GAC1B,EAAY,EAAc,GAC1B,EAAY,EAAc,GAC1B,EAAY,EAAc,IAG9B,EAAY,KACV,EAAY,GACZ,EAAY,EAAc,GAC1B,EAAY,EAAc,GAC1B,EAAY,EAAc,GAC1B,EAAY,EAAc,IAK3B,KAAA,YAAc,EAEb,IAAA,EAAY,IAAI,aAAa,GAsB5B,OArBP,EAAO,EAAU,kBACjB,EAAG,WAAW,EAAG,aAAc,EAAW,EAAG,aAC7C,EAAG,oBAAoB,EAAQ,EAAG,EAAG,OAAO,EAAc,EAAP,EAAU,GAC7D,EAAG,wBAAwB,GAKtB,KAAA,OAAS,EAAG,mBAAmB,EAAS,UACxC,KAAA,WAAa,EAAG,kBAAkB,EAAS,aAGhD,EAAoB,IAAI,CAAC,EAAI,EAAO,MAAO,EAAG,EAAG,EAAG,GAAI,EAAI,EAAO,OAAQ,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IACvG,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QAEvC,EAAG,iBAAiB,KAAK,QAAQ,EAAO,GAEnC,KAAA,sBAAsB,GAE3B,EAAM,SAEC,MAGT,EAAA,UAAA,cAAA,WACO,KAAA,YAAc,GACd,KAAA,SAAW,GAEV,IAUF,EAEA,EACA,EAbE,EAAW,KAAK,SAClB,EAAW,KAAK,SAEhB,EADO,EAAS,KACA,SAChB,EAAM,EAAS,IACf,EAAc,EAAS,YACvB,EAAe,EAAS,aACxB,EAAa,EAAS,OAIpB,EAAA,EAAA,MAGF,EAAe,EAGf,IAAC,EACG,MAAA,IAAI,MAAM,iCAMX,IALqB,mBAAV,IAChB,EAAU,GAIL,EAAe,EAAY,IAAgB,CAChD,EAAU,EAAS,GAGjB,EADE,EACY,EAAQ,EAAc,GAEtB,EAGV,IAAA,EAAkB,IAAI,EAAA,oBAAoB,CAC9C,QAAS,EAAI,QAAQ,KAAK,GAC1B,YAAW,EACX,aAAY,EACZ,MAAO,IAET,EAAgB,oBAAoB,EAAQ,SAAS,aACrD,EAAS,KAAK,GAGT,OAAA,MAGT,EAAA,UAAA,aAAA,SAAa,GACP,IAAC,KAAK,GAAI,OAAO,KAEf,IAAA,EAAA,KAAE,EAAA,EAAA,GAAI,EAAA,EAAA,SAAU,EAAA,EAAA,OAAQ,EAAA,EAAA,UAAW,EAAA,EAAA,OAAQ,EAAA,EAAA,oBAAqB,EAAA,EAAA,YAAa,EAAA,EAAA,SAC/E,EAAS,EAAS,OAChB,EAAA,EAAA,MAAO,EAAA,EAAA,OAAQ,EAAA,EAAA,KACjB,EAAY,KAAK,IAAI,EAAO,EAAK,GAQjC,GALJ,EAAG,MAAM,EAAG,kBACZ,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QACvC,EAAoB,IAAI,CAAC,EAAI,EAAO,MAAO,EAAG,EAAG,EAAG,GAAI,EAAI,EAAO,OAAQ,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IACvG,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QACvC,EAAG,eAAe,KAAK,WAAY,GAC/B,EAAO,GACT,EACG,IAAI,GACJ,YAAY,GACZ,iBAAiB,EAAO,GAAI,EAAO,GAEtC,EAAG,iBAAiB,GAAQ,EAAO,EAAU,OAE7C,EAAG,WAAW,EAAG,MAAO,EAAG,EAAY,OAAS,QAC3C,GAAsB,iBAAX,EAEX,IAAA,IAAI,GAAW,EAAQ,EAAU,EAAQ,GAAW,GAClD,IAAA,IAAI,GAAW,EAAQ,EAAU,EAAQ,GAAW,GAEvD,EACG,IAAI,GACJ,YAAY,GACZ,iBAAiB,EAAO,EAAK,EAAU,GAAS,EAAO,EAAK,EAAU,GAEzE,EAAG,iBAAiB,GAAQ,EAAO,EAAU,OAE7C,EAAG,WAAW,EAAG,MAAO,EAAG,EAAY,OAAS,QAG/C,GAAsB,mBAAX,EAGX,IAFD,IAAA,EAAiB,EACf,EAAW,EAAS,KAAK,SACtB,EAAI,EAAG,EAAI,EAAS,OAAQ,IAAK,CAClC,IACA,EADkB,EAAS,GACG,YAC9B,EAAc,EAAO,EAAG,EAAS,IAElC,IAAI,GAAW,EAAa,EAAU,EAAa,GAAW,GAC5D,IAAI,GAAW,EAAa,EAAU,EAAa,GAAW,GAEjE,EACG,IAAI,GACJ,YAAY,GACZ,iBAAiB,EAAO,EAAK,EAAU,GAAS,EAAO,EAAK,EAAU,GAEzE,EAAG,iBAAiB,KAAK,QAAQ,EAAO,EAAU,OAElD,EAAG,WAAW,EAAG,MAAO,EAAgB,GAG5C,GAAkB,EAGf,OAAA,MAGF,EAAA,SAAP,SAAgB,EAAsB,GAChC,IAGA,EAHA,GAAe,EACf,EAAW,KACX,EAAS,GAGb,EAAM,UAAU,QAAQ,SAAU,GAChC,EAAW,EAAU,SAChB,EAAU,QACX,EAAS,MAAQ,GAChB,EAAS,OAEd,EAAS,KAAK,SAAS,IAAI,SAAA,GACpB,IAAA,IAAI,EAAI,EAAG,EAAI,EAAQ,SAAS,YAAY,OAAQ,IAAK,CACxD,IAAA,EAAW,EAAA,UAAU,EAAE,OAAO,IAAK,EAAE,OAAO,IAC9C,EAAQ,SAAS,YAAY,EAAI,GAAG,GAAI,EAAQ,SAAS,YAAY,EAAI,GAAG,GAC5E,EAAQ,SAAS,YAAY,GAAG,GAAI,EAAQ,SAAS,YAAY,GAAG,IAClE,EAAW,IACb,EAAS,EACT,EAAe,EACf,EAAW,QAMf,GACF,EAAS,SAAS,MAAM,EAAG,IAhPxB,EAAA,SAAW,EACX,EAAA,UAAqB,GAoP9B,EAtPA,CAA2B,EAAA,MAAd,QAAA,MAAA;;AC4BA,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,EAAA,eAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA3Db,IAAA,EAAA,QAAA,UAEA,EAAA,QAAA,WACA,EAAA,QAAA,sBAEA,EAAA,QAAA,WAQM,EAA4B,CAChC,IAAK,KACL,KAAM,GACN,aAAc,KACd,YAAa,KACb,WAAY,KACZ,mBAAoB,KACpB,qBAAsB,KACtB,WAAY,KACZ,MAAO,KACP,MAAO,EAAA,MAAM,OACb,QAAS,GACT,KAAM,KACN,UAAW,GACX,YAAa,EACb,gBAAiB,CACf,OAAQ,CACN,KAAM,QACN,MAAO,EACP,KAAM,EACN,MAAO,GAET,MAAO,CACL,KAAM,QACN,MAAO,EACP,KAAM,EACN,MAAO,GAET,UAAW,CACT,KAAM,QACN,MAAO,EACP,KAAM,EACN,MAAO,KAcb,EAAA,SAAA,GAWE,SAAA,EAAY,GAAZ,IAAA,EACE,EAAA,KAAA,KAAM,IAAS,KAIX,GAHJ,EAAO,UAAU,KAAK,GACtB,EAAK,SAAQ,EAAA,EAAA,GAAO,EAAO,UAAa,IAEnC,EAAS,KAAM,MAAM,IAAI,MAAM,mCAChC,IAAC,EAAS,IAAK,MAAM,IAAI,MAAM,2CAEnC,EAAK,QAAS,EAEN,IAAA,EAAA,EAAA,SAAA,KACJ,GAAA,MAAM,QAAQ,GAChB,EAAK,WAAa,YACb,CAAA,GAAkB,sBAAd,EAAK,KAGR,MAAA,IAAI,MAAM,gFAFhB,EAAK,WAAa,4BAzBX,OA+BL,EAAK,SAAS,IAAI,QAAQ,IAAI,WAAW,UAAY,EAAA,WAAW,kBAAkB,SACpF,QAAQ,KAAK,4DAGf,EACG,QACA,SArCM,EAqTb,OArT4B,EAAA,EAAA,GAwC1B,EAAA,UAAA,OAAA,WAEO,KAAA,gBAGC,IAAA,EAAA,KAAE,EAAA,EAAA,GAAI,EAAA,EAAA,SAAU,EAAA,EAAA,OAAQ,EAAA,EAAA,QAAS,EAAA,EAAA,MAAO,EAAA,EAAA,SAAU,EAAA,EAAA,oBACpD,EAAS,KAAK,OAAS,EAAG,mBAAmB,EAAS,UACtD,EAAU,EAAG,mBAAmB,EAAS,WACzC,EAAe,EAAG,eAClB,EAAc,IAAI,aAAa,GAC/B,EAAY,EAAY,kBAqBrB,OAjBP,EAAoB,IAAI,CACtB,EAAI,EAAO,MAAO,EAAG,EAAG,EACxB,GAAI,EAAI,EAAO,OAAQ,EAAG,EAC1B,EAAG,EAAG,EAAG,GACR,EAAG,EAAG,EAAG,IAGZ,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QACvC,EAAG,iBAAiB,GAAQ,EAAO,GACnC,EAAG,UAAU,EAAS,EAAS,SAC/B,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,WAAW,EAAG,aAAc,EAAa,EAAG,aAE1C,KAAA,sBAAsB,GAE3B,EAAM,SAEC,MAGT,EAAA,UAAA,cAAA,WAEO,KAAA,aAAe,GACf,KAAA,gBAAkB,GAClB,KAAA,SAAW,GAEV,IAGF,EAEA,EACA,EACA,EACA,EACA,EACA,EAVI,EAAF,KAAE,SAAU,EAAZ,KAAY,aACd,EAAA,KAAA,SAAE,EAAA,EAAA,YAAa,EAAA,EAAA,aAAc,EAAA,EAAA,KAAM,EAAA,EAAA,IAAK,EAAA,EAAA,WAGxC,EAAA,KAAA,SAAE,EAAA,EAAA,MAAO,EAAA,EAAA,KAST,IAAC,EACG,MAAA,IAAI,MAAM,iCAKd,GAJwB,mBAAV,IAChB,EAAU,IAGP,EACG,MAAA,IAAI,MAAM,gCAKd,GAJuB,mBAAT,IAChB,EAAS,GAGa,UAApB,KAAK,WAEF,IADC,IAAA,EAAM,EAAK,OACR,EAAI,EAAG,EAAI,EAAK,IAAK,CAE5B,GADA,EAAS,EAAK,IACD,GAAa,QAAQ,GAAK,IAAM,EAAO,GAAc,QAAQ,GAC1E,EAAQ,EAAI,QAAQ,IAAI,EAAA,OAAO,EAAO,GAAc,EAAO,IAAgB,GAGzE,EADE,EACY,EAAQ,EAAG,GAEX,EAId,EADE,EACW,EAAO,EAAG,GAEV,EAIf,EAAS,KAAK,EAAM,EAAG,EAAM,EAAG,EAAY,EAAG,EAAY,EAAG,EAAY,EAAG,GAEvE,IAAA,EAAS,CAAE,OAAM,EAAE,IAAG,EAAE,MAAK,EAAE,YAAW,EAAE,WAAU,IAC3D,EAAa,KAAS,EAAa,GAAO,KACxC,KAAK,GACH,KAAA,gBAAgB,KAAK,GACtB,GACF,EAAW,KAAK,KAAM,EAAQ,EAAO,QAGpC,GAAwB,8BAApB,KAAK,WAET,IADC,EAAM,EAAK,SAAS,OACjB,EAAI,EAAG,EAAI,EAAK,IAAK,CACtB,IAAA,EAAU,EAAK,SAAS,GAE9B,GADA,EAAS,EAAQ,SAAS,aACb,GAAa,QAAQ,GAAK,IAAM,EAAO,GAAc,QAAQ,GAC1E,EAAQ,EAAI,QAAQ,IAAI,EAAA,OAAO,EAAO,GAAc,EAAO,IAAgB,GAGzE,EADE,EACY,EAAQ,EAAG,GAEX,EAId,EADE,EACW,EAAO,EAAG,GAEV,EAIf,EAAS,KAAK,EAAM,EAAG,EAAM,EAAG,EAAY,EAAG,EAAY,EAAG,EAAY,EAAG,GAEvE,EAAS,CAAE,OAAM,EAAE,IAAG,EAAE,MAAK,EAAE,YAAW,EAAE,WAAU,EAAE,QAAO,IACpE,EAAa,KAAS,EAAa,GAAO,KACxC,KAAK,GACH,KAAA,gBAAgB,KAAK,GACtB,GACF,EAAW,KAAK,KAAM,EAAQ,EAAO,GAKpC,OAAA,MAGT,EAAA,UAAA,UAAA,SAAU,GACF,IAAA,EAAA,KAAA,SAAE,EAAA,EAAA,IAAK,EAAA,EAAA,KACT,EAA4B,mBAAT,EAAsB,EAAK,EAAY,MAAQ,EAElE,EAAO,EAAI,UAGR,OAAc,OAAd,EAAqB,KAAK,IAAI,EAAO,EAAK,GAAO,GAG1D,EAAA,UAAA,aAAA,SAAa,GACP,IAAC,KAAK,GAAI,OAAO,KAEf,IAAA,EAAA,KAAE,EAAA,EAAA,GAAI,EAAA,EAAA,OAAQ,EAAA,EAAA,SAAU,EAAA,EAAA,UAAW,EAAA,EAAA,OAAQ,EAAA,EAAA,oBAAqB,EAAA,EAAA,SAClE,EAAM,EAAS,IACb,EAAA,EAAA,OACF,EAAO,EAAI,UACX,EAAQ,KAAK,IAAI,EAAG,GAqBjB,OAlBP,EAAoB,IAAI,CACtB,EAAI,EAAO,MAAO,EAAG,EAAG,EACxB,GAAI,EAAI,EAAO,OAAQ,EAAG,EAC1B,EAAG,EAAG,EAAG,GACR,EAAG,EAAG,EAAG,IAIZ,EACG,IAAI,GACJ,YAAY,GACZ,iBAAiB,EAAO,GAAI,EAAO,GAEtC,EAAG,MAAM,EAAG,kBACZ,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QACvC,EAAG,iBAAiB,GAAQ,EAAO,EAAU,OAC7C,EAAG,WAAW,EAAG,OAAQ,EAAG,EAAS,OAAS,GAEvC,MAGT,EAAA,UAAA,OAAA,SAAO,GAaE,IAZD,IAKF,EACA,EACA,EACA,EACA,EATE,EAAe,EAAO,IAAM,IAC9B,EAAe,EAAO,IAAM,IAC5B,EAA0B,GAE1B,EAAI,EAAO,IAAM,IAQd,GAAK,EAAM,GAAK,IAEd,IADP,EAAI,EAAO,IAAM,IACV,GAAK,EAAM,GAAK,IAGjB,GAFJ,EAAM,EAAE,QAAQ,GAAK,IAAM,EAAE,QAAQ,GACrC,EAAQ,KAAK,aAAa,GAIjB,IAFP,EAAS,EACT,EAAW,EAAM,OACV,EAAS,EAAU,IACxB,EAAQ,KAAK,EAAM,IAMnB,IAAA,EAAA,KAAA,SAAA,IAGD,OAAA,EAAO,QACZ,EACA,EAAQ,OAAS,EACb,EACA,KAAK,gBACT,IAIG,EAAA,QAAP,SAAe,EAAwB,EAAwB,GACzD,OAAA,EAAO,OAAS,EAAU,KACvB,EAAO,OAAO,SAAC,EAAM,GAIlB,OAHa,EAAA,iBAAiB,EAAgB,EAAK,OAAQ,GAChD,EAAA,iBAAiB,EAAgB,EAAK,OAAQ,GAE1B,EAAO,KAI3C,EAAA,SAAP,SAAgB,EAAsB,GAC9B,IAGF,EACA,EACA,EACA,EACA,EACA,EACA,EATE,EAAkC,GACpC,EAAkB,GAsBlB,GAXJ,EAAO,UAAU,QAAQ,SAAC,GACxB,EAAW,EAAU,SAChB,EAAU,QACX,EAAS,MAAQ,GAChB,EAAS,QAEd,EAAc,EAAU,OAAO,EAAE,QACjC,EAAgB,EAAY,KAAO,EACnC,EAAgB,KAAK,QAGnB,EAAgB,OAAS,IACxB,GAIS,QAFd,EAAQ,KAAK,QAAQ,EAAE,OAAQ,EAAiB,MAIhD,EAAW,EAAgB,EAAM,MAC7B,CACE,IAAA,EAAA,EAAA,SAAE,EAAA,EAAA,YAAa,EAAA,EAAA,aAAc,EAAA,EAAA,YAAa,EAAA,EAAA,MAK5C,OAHJ,EAAc,IAAI,EAAA,OAAO,EAAM,OAAO,GAAc,EAAM,OAAO,IACjE,EAAK,EAAI,mBAAmB,GAExB,EAAA,cACF,EACA,EAAE,WACF,EAAM,WAAa,QAGD,KADlB,EAAS,EAAM,EAAG,EAAM,SAAW,EAAM,OAAQ,KACnB,OAN5B,IA3SC,EAAA,UAAsB,GACtB,EAAA,SAAW,EACX,EAAA,KAAO,GAkThB,EArTA,CAA4B,EAAA,MAAf,QAAA,OAAA;;AC7BA,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,EAAA,eAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAhCb,IAAA,EAAA,EAAA,QAAA,WACA,EAAA,EAAA,QAAA,oBACA,EAAA,EAAA,QAAA,mBAEA,EAAA,QAAA,UAEA,EAAA,QAAA,WACA,EAAA,QAAA,sBAIa,QAAA,SAA2B,CACtC,IAAK,KACL,KAAM,GACN,aAAc,KACd,YAAa,KACb,WAAY,KACZ,mBAAoB,KACpB,qBAAsB,KACtB,MAAO,KACP,MAAO,EAAA,MAAM,OACb,UAAW,GACX,QAAS,GACT,gBAAiB,CACf,MAAO,CACL,KAAM,QACN,MAAO,EACP,KAAM,KAKZ,IAAA,EAAA,SAAA,GAME,SAAA,EAAY,GAAZ,IAAA,EACE,EAAA,KAAA,KAAM,IAAS,KAIX,GAHJ,EAAO,UAAU,KAAK,GACtB,EAAK,SAAQ,EAAA,EAAA,GAAQ,EAAO,UAAa,IAEpC,EAAS,KAAM,MAAM,IAAI,MAAM,mCAChC,IAAC,EAAS,IAAK,MAAM,IAAI,MAAM,2CAZ1B,OAaT,EAAK,cAAgB,KAErB,EACG,QACA,SAjBM,EAoMb,OApM4B,EAAA,EAAA,GAoB1B,EAAA,UAAA,OAAA,WACO,KAAA,gBAGC,IAAA,EAAA,KAAE,EAAA,EAAA,oBAAqB,EAAA,EAAA,SAAU,EAAA,EAAA,OAAQ,EAAA,EAAA,GAAI,EAAA,EAAA,MAAO,EAAA,EAAA,SAAU,EAAA,EAAA,QAChE,EAAe,EAAG,eAClB,EAAY,IAAI,aAAa,GAC7B,EAAY,EAAU,kBACtB,EAAS,EAAG,kBAAkB,EAAS,UACvC,EAAU,EAAG,mBAAmB,EAAS,WAuBtC,OArBP,EAAG,UAAU,EAAS,EAAS,SAC/B,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,WAAW,EAAG,aAAc,EAAW,EAAG,aAC7C,EAAG,oBAAoB,EAAQ,EAAG,EAAG,OAAO,EAAmB,EAAZ,EAAe,GAClE,EAAG,wBAAwB,GAKtB,KAAA,OAAS,EAAG,mBAAmB,EAAS,UAG7C,EAAoB,IAAI,CAAC,EAAI,EAAO,MAAO,EAAG,EAAG,EAAG,GAAI,EAAI,EAAO,OAAQ,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IACvG,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QAEvC,EAAG,iBAAiB,KAAK,QAAQ,EAAO,GAEnC,KAAA,sBAAsB,GAE3B,EAAM,SAEC,MAGT,EAAA,UAAA,cAAA,WACO,KAAA,SAAW,GACX,KAAA,cAAgB,IAAI,EAAA,QAEnB,IAIF,EACA,EACA,EACA,EAEA,EACA,EACA,EAEA,EACA,EACA,EACA,EACA,EAjBI,EAAF,KAAE,SAAU,EAAZ,KAAY,cAAe,EAA3B,KAA2B,SAC7B,EAAO,EAAS,KAOd,EAAA,EAAA,MAIF,EAAe,EAQX,OAAA,EAAK,MACN,IAAA,UACH,EAAc,sBAAsB,CAClC,KAAM,oBACN,SAAU,CAAC,KAEb,EAAW,EAAA,QAAe,GAC1B,MACG,IAAA,eACH,EAAc,sBAAsB,CAClC,KAAM,oBACN,SAAU,CAAC,CACT,KAAM,UACN,WAAY,CAAE,GAAI,OAClB,SAAU,CAAE,YAAa,EAAK,iBAGlC,EAAW,EAAA,QAAe,GAC1B,MACF,QACE,EAAc,sBAAsB,GACpC,EAAW,EAAK,SAIhB,GAFJ,EAAa,EAAS,QAEjB,EACG,MAAA,IAAI,MAAM,iCAMX,IALqB,mBAAV,IAChB,EAAU,GAIL,EAAe,EAAY,IAAgB,CAChD,EAAU,EAAS,GACnB,EAAY,GAIV,EADE,EACY,EAAQ,EAAc,GAEtB,EAGhB,GAAe,EAAQ,UAAY,GAAS,YAC5C,EAAO,EAAA,QAAO,QAAQ,GACtB,EAAU,EAAA,QAAO,EAAK,SAAU,EAAK,MAAO,EAAK,YACjD,EAAM,EAAY,GAAG,GAAG,OACnB,IAAA,IAAI,EAAI,EAAG,EAAO,EAAQ,OAAQ,EAAI,EAAM,IAAK,CAEhD,GADJ,EAAQ,EAAQ,GACgB,iBAArB,EAAK,SAAS,GAGjB,MAAA,IAAI,MAAM,qBAFhB,EAAU,KAAK,EAAK,SAAS,EAAQ,EAAM,EAAS,cAAe,EAAK,SAAS,EAAQ,EAAM,EAAS,cAMvG,IAAI,EAAI,EAAG,EAAO,EAAU,OAAQ,EAAI,EAAM,EACjD,EAAQ,EAAS,IAAI,QAAQ,IAAI,EAAA,OAAO,EAAU,KAAM,EAAU,MAAO,GACzE,EAAS,KAAK,EAAM,EAAG,EAAM,EAAG,EAAY,EAAG,EAAY,EAAG,EAAY,GAIvE,OAAA,MAGT,EAAA,UAAA,aAAA,SAAa,GACP,IAAC,KAAK,GAAI,OAAO,KAEb,IAAA,EAAA,EAAA,MAAO,EAAA,EAAA,OAAQ,EAAA,EAAA,OACnB,EAAY,KAAK,UACjB,EAAsB,KAAK,oBAG/B,EAAoB,IAAI,CACtB,EAAI,EAAO,MAAO,EAAG,EAAG,EACxB,GAAI,EAAI,EAAO,OAAQ,EAAG,EAC1B,EAAG,EAAG,EAAG,GACR,EAAG,EAAG,EAAG,IAIZ,EACG,IAAI,GACJ,YAAY,GACZ,iBAAiB,EAAO,GAAI,EAAO,GAEhC,IAAA,EAAK,KAAK,GAQT,OAPP,EAAG,MAAM,EAAG,kBACZ,EAAG,SAAS,EAAG,EAAG,EAAO,MAAO,EAAO,QAGvC,EAAG,iBAAiB,KAAK,QAAQ,EAAO,EAAU,OAClD,EAAG,WAAW,EAAG,UAAW,EAAG,KAAK,SAAS,OAAS,GAE/C,MAGF,EAAA,SAAP,SAAgB,EAAsB,GAChC,IAAA,EACA,EACA,EAeG,OAZP,EAAO,UAAU,QAAQ,SAAU,GACjC,EAAW,EAAU,SAChB,EAAU,QACX,EAAS,MAAQ,GAChB,EAAS,QAEd,EAAU,EAAU,cAAc,OAAO,EAAE,OAAO,IAAK,EAAE,OAAO,QAE9D,EAAS,EAAS,MAAM,EAAG,WAIb,IAAX,GAAuB,GAjMzB,EAAA,UAAsB,GACtB,EAAA,SAAW,QAAA,SAkMpB,EApMA,CAA4B,EAAA,MAAf,QAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACsGZ,aAAA,IAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,EAAA,MAAA,KAAA,gBAAA,WAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,GAAA,UAAA,GAAA,OAAA,IAAA,EAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAAA,IAAA,EAAA,UAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,GAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IApID,IAAA,EAAA,QAAA,WAEA,EAAA,QAAA,YACA,EAAA,QAAA,YAGA,EAAA,EAAA,QAAA,iCAEA,EAAA,EAAA,QAAA,+BAEA,EAAA,EAAA,QAAA,iCAEA,EAAA,EAAA,QAAA,gCAEA,EAAA,EAAA,QAAA,yCAEA,EAAA,EAAA,QAAA,kCAEA,EAAA,EAAA,QAAA,mCAEM,EAAS,CACb,OAAM,EAAA,QACN,SAAU,CACR,IAAG,EAAA,QACH,MAAK,EAAA,QACL,KAAI,EAAA,QACJ,aAAY,EAAA,QACZ,OAAM,EAAA,QACN,QAAO,EAAA,UAIX,EAAA,WAAA,SAAA,IACE,KAAA,aAAuB,EACvB,KAAA,YAAsB,EACtB,KAAA,KAAc,GACd,KAAA,OAAS,EAET,KAAA,OAAwB,EAAA,OACxB,KAAA,OAAwB,EAAA,OACxB,KAAA,MAAsB,EAAA,MAmFxB,OAjFE,EAAA,UAAA,eAAA,WAGS,OAFF,KAAA,aAAe,EACf,KAAA,YAAc,EACZ,MAGT,EAAA,UAAA,cAAA,WAGS,OAFF,KAAA,YAAc,EACd,KAAA,aAAe,EACb,MAGT,OAAA,eAAI,EAAA,UAAA,YAAS,CAAb,IAAA,WACE,OAAA,EACK,EAAA,OAAO,UACP,EAAA,MAAM,UACN,EAAA,OAAO,YAJD,YAAA,EA8Ed,cAAA,IAtEC,EAAA,UAAA,OAAA,SAAO,GAAP,IAAA,EAAA,KACS,OAAA,IAAI,KAAK,OAAM,EAAA,CACpB,WAAY,EAAM,WAAW,KAAK,MAClC,YAAa,EAAM,YACnB,aAAc,EAAM,aACpB,mBAAoB,WACX,OAAA,EAAK,OAAO,QAErB,qBAAsB,WACb,OAAA,EAAK,OAAO,SAAS,QAE3B,KAIP,EAAA,UAAA,OAAA,SAAO,GAAP,IAAA,EAAA,KACS,OAAA,IAAI,KAAK,OAAM,EAAA,CACpB,WAAY,KAAK,WAAW,KAAK,MACjC,YAAa,KAAK,YAClB,aAAc,KAAK,aACnB,mBAAoB,WACX,OAAA,EAAK,OAAO,QAErB,qBAAsB,WACb,OAAA,EAAK,OAAO,SAAS,UAE3B,KAIP,EAAA,UAAA,MAAA,SAAM,GAAN,IAAA,EAAA,KACS,OAAA,IAAI,KAAK,MAAK,EAAA,CACnB,WAAY,KAAK,WAAW,KAAK,MACjC,YAAa,KAAK,YAClB,aAAc,KAAK,aACnB,mBAAoB,WACX,OAAA,EAAK,OAAO,QAErB,qBAAsB,WACb,OAAA,EAAK,OAAO,SAAS,UAE3B,KAIP,EAAA,UAAA,WAAA,SAAW,GACL,KAAK,KAAK,QAAQ,GAAO,IACtB,KAAA,KAAK,KAAK,GACf,EAAI,GAAG,QAAS,SAAC,GACX,IAAA,EAEA,YAAQ,KADZ,EAAM,EAAA,OAAO,SAAS,EAAG,IACK,OAGlB,KADZ,EAAM,EAAA,MAAM,SAAS,EAAG,IACM,OAGlB,KADZ,EAAM,EAAA,OAAO,SAAS,EAAG,IACK,OAA1B,MAIZ,EA3FA,GA6FM,EAAQ,IAAI,EAClB,QAAA,QAAe,OAAO,QAAU,EACV,oBAAX,QAA0B,OAAO,IAE1C,OAAM,EAAM,MAAQ,EAEpB,OAAM,EAAM,MAAQ","file":"glify.js","sourceRoot":"../src","sourcesContent":["export class MapMatrix {\n  array: Float32Array;\n  constructor() {\n    this.array = new Float32Array(16);\n  }\n  set(array: ArrayLike<number>, offset?: number): this {\n    this.array.set(array, offset);\n    return this;\n  }\n  translateMatrix(tx: number, ty: number) {\n    const { array } = this;\n    // translation is in last column of matrix\n    array[12] += array[0] * tx + array[4] * ty;\n    array[13] += array[1] * tx + array[5] * ty;\n    array[14] += array[2] * tx + array[6] * ty;\n    array[15] += array[3] * tx + array[7] * ty;\n\n    return this;\n  }\n  scaleMatrix(scale: number) {\n    const { array } = this;\n    // scaling x and y, which is just scaling first two columns of matrix\n    array[0] *= scale;\n    array[1] *= scale;\n    array[2] *= scale;\n    array[3] *= scale;\n\n    array[4] *= scale;\n    array[5] *= scale;\n    array[6] *= scale;\n    array[7] *= scale;\n\n    return this;\n  }\n}\n","/* It was tried to allow for better tree shaking to import leaflet's src files one by one,\n * but this caused node not to work, because leaflet uses import/export.  So it was easier to\n * simply import it directly.  It causes a 70kb growth in the bundle, but the current time to\n * manage vs size ratio didn't justify continuing.\n */\nimport * as L from 'leaflet';\n\nlet exports = L;\n\nif (window && window.L) {\n  exports = window.L;\n}\n\nmodule.exports = exports;","/*\noriginally taken from: http://www.sumbera.com/gist/js/leaflet/canvas/L.CanvasOverlay.js, added and customized as part of this lib because of need from library\n Generic  Canvas Overlay for leaflet,\n Stanislav Sumbera, April , 2014\n\n - added userDrawFunc that is called when Canvas need to be redrawn\n - added few useful params fro userDrawFunc callback\n - fixed resize map bug\n inspired & portions taken from  :   https://github.com/Leaflet/Leaflet.heat\n */\n\nimport {\n  LatLngBounds,\n  Map,\n  Point,\n  Layer,\n  Util,\n  Browser,\n  Bounds,\n  DomUtil,\n  LatLng,\n  ZoomAnimEvent,\n} from './leaflet-bindings';\n\nexport interface ICanvasOverlayDrawEvent {\n  canvas: HTMLCanvasElement;\n  bounds: LatLngBounds;\n  offset: Point;\n  scale: number;\n  size: Point;\n  zoomScale: number;\n  zoom: number;\n}\n\nexport interface IUserDrawFunc {\n  (event: ICanvasOverlayDrawEvent): void\n}\n\nexport class CanvasOverlay extends Layer {\n  _userDrawFunc: IUserDrawFunc;\n  _map: Map;\n  _redrawCallbacks: Function[];\n  canvas: HTMLCanvasElement;\n\n  _frame?: number;\n\n  constructor(\n    userDrawFunc: IUserDrawFunc\n  ) {\n    super();\n    this._userDrawFunc = userDrawFunc;\n    this._frame = null;\n    this._redrawCallbacks = [];\n  }\n\n  drawing(userDrawFunc): this {\n    this._userDrawFunc = userDrawFunc;\n    return this;\n  }\n\n  params(options): this {\n    Util.setOptions(this, options);\n    return this;\n  }\n\n  redraw(callback?) {\n    if (typeof callback === 'function') {\n      this._redrawCallbacks.push(callback);\n    }\n    if (this._frame === null) {\n      this._frame = Util.requestAnimFrame(this._redraw, this);\n    }\n    return this;\n  }\n\n  onAdd(map): this {\n    this._map = map;\n    this.canvas = this.canvas || document.createElement('canvas');\n\n    const size = map.getSize()\n      , animated = map.options.zoomAnimation && Browser.any3d\n      ;\n\n    this.canvas.width = size.x;\n    this.canvas.height = size.y;\n\n    this.canvas.className = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');\n\n    map._panes.overlayPane.appendChild(this.canvas);\n\n    map.on('moveend', this._reset, this);\n    map.on('resize',  this._resize, this);\n\n    if (animated) {\n      map.on('zoomanim', Layer ? this._animateZoom : this._animateZoomNoLayer, this);\n    }\n\n    this._reset();\n    return this;\n  }\n\n  onRemove(map): this {\n    map.getPanes().overlayPane.removeChild(this.canvas);\n\n    map.off('moveend', this._reset, this);\n    map.off('resize', this._resize, this);\n\n    if (map.options.zoomAnimation && Browser.any3d) {\n      map.off('zoomanim', Layer ? this._animateZoom : this._animateZoomNoLayer, this);\n    }\n    return this;\n  }\n\n  addTo(map): this {\n    map.addLayer(this);\n    return this;\n  }\n\n  _resize(resizeEvent): void {\n    this.canvas.width  = resizeEvent.newSize.x;\n    this.canvas.height = resizeEvent.newSize.y;\n  }\n\n  _reset(): void {\n    const topLeft = this._map.containerPointToLayerPoint([0, 0]);\n    DomUtil.setPosition(this.canvas, topLeft);\n    this._redraw();\n  }\n\n  _redraw(): void {\n    const { _map, canvas } = this\n      , size = _map.getSize()\n      , bounds = _map.getBounds()\n      , zoomScale = (size.x * 180) / (20037508.34  * (bounds.getEast() - bounds.getWest())) // resolution = 1/zoomScale\n      , zoom = _map.getZoom()\n      , topLeft = new LatLng(bounds.getNorth(), bounds.getWest())\n      , offset = this._unclampedProject(topLeft, 0)\n      ;\n\n    if (this._userDrawFunc) {\n      this._userDrawFunc({\n        bounds,\n        canvas,\n        offset,\n        scale: Math.pow(2, zoom),\n        size,\n        zoomScale,\n        zoom,\n      });\n    }\n\n    while (this._redrawCallbacks.length > 0) {\n      this._redrawCallbacks.shift()(this);\n    }\n\n    this._frame = null;\n  }\n\n  _animateZoom(e: ZoomAnimEvent): void {\n    const { _map } = this\n      , scale = _map.getZoomScale(e.zoom, _map.getZoom())\n      // @ts-ignore\n      , offset = this._unclampedLatLngBoundsToNewLayerBounds(_map.getBounds(), e.zoom, e.center).min\n      ;\n    DomUtil.setTransform(this.canvas, offset, scale);\n  }\n\n  _animateZoomNoLayer(e: ZoomAnimEvent): void {\n    const { _map } = this\n      , scale = _map.getZoomScale(e.zoom, _map.getZoom())\n      // @ts-ignore\n      , offset = _map._getCenterOffset(e.center)\n        ._multiplyBy(-scale)\n        // @ts-ignore\n        .subtract(_map._getMapPanePos())\n      ;\n    DomUtil.setTransform(this.canvas, offset, scale);\n  }\n\n  _unclampedProject(latlng: LatLng, zoom: number): Point {\n    // imported partly from https://github.com/Leaflet/Leaflet/blob/1ae785b73092fdb4b97e30f8789345e9f7c7c912/src/geo/projection/Projection.SphericalMercator.js#L21\n    // used because they clamp the latitude\n    const { crs } = this._map.options\n      // @ts-ignore\n      , { R } = crs.projection\n      , d = Math.PI / 180\n      , lat = latlng.lat\n      , sin = Math.sin(lat * d)\n      , projectedPoint = new Point(\n          // @ts-ignore\n          R * latlng.lng * d,\n          // @ts-ignore\n          R * Math.log((1 + sin) / (1 - sin)) / 2\n        )\n      , scale = crs.scale(zoom)\n      ;\n    // @ts-ignore\n    return crs.transformation._transform(projectedPoint, scale);\n  }\n\n  _unclampedLatLngBoundsToNewLayerBounds(latLngBounds: LatLngBounds, zoom: number, center: LatLng): Bounds {\n    // imported party from https://github.com/Leaflet/Leaflet/blob/84bc05bbb6e4acc41e6f89ff7421dd7c6520d256/src/map/Map.js#L1500\n    // used because it uses crs.projection.project, which clamp the latitude\n    // @ts-ignore\n    const topLeft = this._map._getNewPixelOrigin(center, zoom);\n    return new Bounds([\n      this._unclampedProject(latLngBounds.getSouthWest(), zoom).subtract(topLeft),\n      this._unclampedProject(latLngBounds.getNorthWest(), zoom).subtract(topLeft),\n      this._unclampedProject(latLngBounds.getSouthEast(), zoom).subtract(topLeft),\n      this._unclampedProject(latLngBounds.getNorthEast(), zoom).subtract(topLeft)\n    ]);\n  }\n}\n","import { IColor } from './color';\nimport { Map, Point } from './leaflet-bindings';\nimport { MapMatrix } from './map-matrix';\nimport { CanvasOverlay, ICanvasOverlayDrawEvent } from './canvas-overlay';\n\nexport interface IShaderVariable {\n  type: 'FLOAT';\n  start: number;\n  size: number;\n  bytes?: number;\n  normalize?: boolean;\n}\n\nexport interface IBaseSettings {\n  map: Map;\n  data: any;\n  shaderVariables?: {\n    [name: string]: IShaderVariable\n  }\n  longitudeKey?: number;\n  latitudeKey?: number;\n  setupClick?: (map: Map) => void;\n  vertexShaderSource?: (() => string) | string;\n  fragmentShaderSource?: (() => string) | string;\n  canvas?: HTMLCanvasElement;\n  click?: (e, feature, xy: Point) => boolean | void;\n  color?: ((featureIndex: number, feature: any) => IColor) | IColor;\n  className?: string;\n  opacity?: number;\n  preserveDrawingBuffer?: boolean;\n}\n\nexport abstract class Base<T extends IBaseSettings = IBaseSettings> {\n  active: boolean;\n  fragmentShader: any;\n  canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext;\n  layer: CanvasOverlay;\n  mapMatrix: MapMatrix;\n  matrix: WebGLUniformLocation;\n  pixelsToWebGLMatrix: Float32Array;\n  program: WebGLProgram;\n  settings: T;\n  vertexShader: any;\n  vertices: any;\n\n  abstract render();\n\n  constructor(settings: T) {\n    this.pixelsToWebGLMatrix = new Float32Array(16);\n    this.mapMatrix = new MapMatrix();\n    this.active = true;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.program = null;\n    this.matrix = null;\n    this.vertices = null;\n    const preserveDrawingBuffer = Boolean(settings.preserveDrawingBuffer);\n    const layer = this.layer = new CanvasOverlay((context) => this.drawOnCanvas(context))\n      .addTo(settings.map);\n    const canvas = this.canvas = layer.canvas;\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    canvas.style.position = 'absolute';\n    if (settings.className) {\n      canvas.className += ' ' + settings.className;\n    }\n    this.gl = (\n      canvas.getContext('webgl2', { preserveDrawingBuffer })\n      || canvas.getContext('webgl', { preserveDrawingBuffer })\n      || canvas.getContext('experimental-webgl', { preserveDrawingBuffer })) as WebGLRenderingContext;\n  }\n\n  abstract drawOnCanvas(context: ICanvasOverlayDrawEvent): this;\n\n  attachShaderVariables(byteCount: number): this {\n    if (!this.settings.shaderVariables) {\n      return this;\n    }\n    const bytes = 5;\n\n    const { gl, program } = this;\n    const { shaderVariables } = this.settings;\n    for (const name in shaderVariables) {\n      if (!shaderVariables.hasOwnProperty(name)) continue;\n      const shaderVariable = shaderVariables[name];\n      const loc = gl.getAttribLocation(program, name);\n      if (loc < 0) {\n        throw new Error('shader variable ' + name + ' not found');\n      }\n      gl.vertexAttribPointer(\n        loc,\n        shaderVariable.size,\n        gl[shaderVariable.type],\n        !!shaderVariable.normalize,\n        byteCount * (shaderVariable.bytes || bytes),\n        byteCount * shaderVariable.start);\n      gl.enableVertexAttribArray(loc);\n    }\n\n    return this;\n  }\n\n  setData(data): this {\n    this.settings.data = data;\n    return this;\n  }\n\n  setup() {\n    const settings = this.settings;\n    if (settings.click) {\n      settings.setupClick(settings.map);\n    }\n\n    return this\n      .setupVertexShader()\n      .setupFragmentShader()\n      .setupProgram();\n  }\n\n  setupVertexShader() {\n    const gl = this.gl\n      , settings = this.settings\n      , vertexShaderSource = typeof settings.vertexShaderSource === 'function'\n          ? settings.vertexShaderSource()\n          : settings.vertexShaderSource\n      , vertexShader = gl.createShader(gl.VERTEX_SHADER)\n      ;\n\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.compileShader(vertexShader);\n\n    this.vertexShader = vertexShader;\n\n    return this;\n  }\n\n  setupFragmentShader() {\n    const gl = this.gl\n      , settings = this.settings\n      , fragmentShaderSource = typeof settings.fragmentShaderSource === 'function'\n          ? settings.fragmentShaderSource()\n          : settings.fragmentShaderSource\n      , fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n      ;\n\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    gl.compileShader(fragmentShader);\n\n    this.fragmentShader = fragmentShader;\n\n    return this;\n  }\n\n  setupProgram(): this {\n    // link shaders to create our program\n    const gl = this.gl\n      , program = gl.createProgram()\n      ;\n\n    gl.attachShader(program, this.vertexShader);\n    gl.attachShader(program, this.fragmentShader);\n    gl.linkProgram(program);\n    gl.useProgram(program);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n\n    this.program = program;\n\n    return this;\n  }\n\n  addTo(map) {\n    this.layer.addTo(map || this.settings.map);\n    this.active = true;\n    return this.render();\n  }\n\n  remove() {\n    this.settings.map.removeLayer(this.layer as any);\n    this.active = false;\n    return this;\n  }\n}","export interface IColor {\n  r: number;\n  g: number;\n  b: number;\n}\n\nconst green: IColor = {r: 0, g: 1, b: 0};\nconst red: IColor = {r: 1, g: 0, b: 0};\nconst blue: IColor = {r: 0, g: 0, b: 1};\nconst teal: IColor = {r: 0, g: 1, b: 1};\nconst yellow: IColor = {r: 1, g: 1, b: 0};\n\nconst white: IColor = {r: 1, g: 1, b: 1};\nconst black: IColor = {r: 0, g: 0, b: 0};\n\nconst gray: IColor = {r: 0.5, g: 0.5, b: 0.5};\n\nexport class Color {\n  static green;\n  static red;\n  static blue;\n  static teal;\n  static yellow;\n  static white;\n  static black;\n  static gray;\n  static get grey() {\n    return gray;\n  }\n\n  static fromHex(hex): IColor | null {\n    if (hex.length < 6) return null;\n    hex = hex.toLowerCase();\n\n    if (hex[0] === '#') {\n      hex = hex.substring(1, hex.length);\n    }\n\n    const r = parseInt(hex[0] + hex[1], 16)\n      , g = parseInt(hex[2] + hex[3], 16)\n      , b = parseInt(hex[4] + hex[5], 16)\n      ;\n    return { r: r / 255, g: g / 255, b: b / 255 };\n  }\n\n  static random(): IColor {\n    return {\n      r: Math.random(),\n      g: Math.random(),\n      b: Math.random()\n    };\n  }\n\n  static pallet(): IColor {\n    switch (Math.round(Math.random() * 4)) {\n      case 0:\n        return green;\n      case 1:\n        return red;\n      case 2:\n        return blue;\n      case 3:\n        return teal;\n      case 4:\n        return yellow;\n    }\n  }\n}","import { LatLng } from './leaflet-bindings';\nimport { IColor } from './color';\nimport { IPixel } from './pixel';\n\ninterface ILineFeatureVerticesSettings {\n  project: (coordinates: LatLng, distance: number) => IPixel;\n  color: IColor;\n  latitudeKey?: number;\n  longitudeKey?: number;\n}\n\nexport class LineFeatureVertices {\n  project: (coordinates: LatLng, distance: number) => IPixel;\n  latitudeKey?: number;\n  longitudeKey?: number;\n  color: IColor;\n  vertexCount: number;\n  array: number[];\n  length: number;\n\n  constructor(settings: ILineFeatureVerticesSettings) {\n    Object.assign(this, settings);\n    this.vertexCount = 0;\n    this.array = [];\n    this.length = 0;\n  }\n\n  fillFromCoordinates(coordinates) {\n    const { color } = this;\n    for (let i = 0; i < coordinates.length; i++) {\n      if (Array.isArray(coordinates[i][0])) {\n        this.fillFromCoordinates(coordinates[i]);\n        continue;\n      }\n      const pixel = this.project(\n        new LatLng(\n          coordinates[i][this.latitudeKey],\n          coordinates[i][this.longitudeKey]\n        ), 0);\n      this.push(pixel.x, pixel.y, color.r, color.g, color.b);\n      if (i !== 0 && i !== coordinates.length - 1) {\n        this.vertexCount += 1;\n      }\n      this.vertexCount += 1;\n    }\n  }\n\n  push(...args) {\n    this.array.push(...args);\n    this.length = this.array.length;\n  }\n}","import { LatLng, Map } from './leaflet-bindings';\n\nexport function defaults(userSettings, defaults) {\n  const settings = {};\n\n  for (const i in defaults) {\n    if (!defaults.hasOwnProperty(i)) continue;\n    settings[i] = (userSettings.hasOwnProperty(i) ? userSettings[i] : defaults[i]);\n  }\n\n  return settings;\n}\n\n// -- converts latlon to pixels at zoom level 0 (for 256x256 tile size) , inverts y coord )\n// -- source : http://build-failed.blogspot.cz/2013/02/displaying-webgl-data-on-google-maps.html\nexport function latLonToPixel(latitude, longitude) {\n  const pi180 = Math.PI / 180.0,\n    pi4 = Math.PI * 4,\n    sinLatitude = Math.sin(latitude * pi180),\n    pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (pi4)) * 256,\n    pixelX = ((longitude + 180) / 360) * 256;\n\n  return {x: pixelX, y: pixelY};\n}\n\nexport function pointInCircle(centerPoint, checkPoint, radius) {\n  const distanceSquared = (centerPoint.x - checkPoint.x) * (centerPoint.x - checkPoint.x) + (centerPoint.y - checkPoint.y) * (centerPoint.y - checkPoint.y);\n  return distanceSquared <= radius * radius;\n}\n\nexport function pDistance(x, y, x1, y1, x2, y2): number {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const len_sq = C * C + D * D;\n  let param = -1;\n  if (len_sq !== 0) //in case of 0 length line\n    param = dot / len_sq;\n\n  let xx, yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  let dx = x - xx;\n  let dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function vectorDistance(dx: number, dy: number): number {\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function locationDistance(location1: LatLng, location2: LatLng, map: Map): number {\n  const point1 = map.latLngToLayerPoint(location1)\n    , point2 = map.latLngToLayerPoint(location2)\n    , dx = point1.x - point2.x\n    , dy = point1.y - point2.y\n  ;\n  return vectorDistance(dx, dy);\n}\n\nexport function debugPoint(containerPoint) {\n  const el = document.createElement('div')\n    , s = el.style\n    , x = containerPoint.x\n    , y = containerPoint.y\n  ;\n\n  s.left = x + 'px';\n  s.top = y + 'px';\n  s.width = '10px';\n  s.height = '10px';\n  s.position = 'absolute';\n  s.backgroundColor = '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n\n  document.body.appendChild(el);\n}","import { Base, IBaseSettings } from './base';\nimport { ICanvasOverlayDrawEvent } from './canvas-overlay';\nimport { Color, IColor } from './color';\nimport { Map, LeafletMouseEvent, LatLng } from './leaflet-bindings';\nimport { LineFeatureVertices } from './line-feature-vertices';\nimport { pDistance } from './utils';\n\nexport interface ILinesSettings extends IBaseSettings {\n  weight: ((i: number, feature: any) => number) | number;\n}\n\nconst defaults: ILinesSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  setupClick: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  click: null,\n  color: Color.random,\n  className: '',\n  opacity: 0.5,\n  weight: 2,\n  shaderVariables: {\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 3\n    }\n  }\n};\n\nexport class Lines extends Base<ILinesSettings> {\n  static defaults = defaults;\n  static instances: Lines[] = [];\n\n  allVertices: number[];\n  vertices: LineFeatureVertices[];\n  aPointSize: number;\n\n  constructor(settings: ILinesSettings) {\n    super(settings);\n    Lines.instances.push(this);\n    this.settings = { ...Lines.defaults, ...settings };\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n\n    this.active = true;\n    this.allVertices = [];\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n\n    const pixelsToWebGLMatrix = this.pixelsToWebGLMatrix\n      , settings = this.settings\n      , { canvas, gl, layer, vertices, program } = this\n      , vertexBuffer = gl.createBuffer()\n      , vertex = gl.getAttribLocation(program, 'vertex')\n      , opacity = gl.getUniformLocation(program, 'opacity')\n      ;\n\n    gl.uniform1f(opacity, settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    /*\n    Transforming lines according to the rule:\n    1. Take one line (single feature)\n    [[0,0],[1,1],[2,2]]\n    2. Split the line in segments, duplicating all coordinates except first and last one\n    [[0,0],[1,1],[2,2]] => [[0,0],[1,1],[1,1],[2,2]]\n    3. Do this for all lines and put all coordinates in array\n    */\n    let size = vertices.length;\n    const allVertices = [];\n    for (let i = 0; i < size; i++) {\n      const vertexArray = vertices[i].array;\n      const length = vertexArray.length / 5;\n      for (let j = 0; j < length; j++) {\n        const vertexIndex = j * 5;\n        if (j !== 0 && j !== (length - 1)) {\n          allVertices.push(\n            vertexArray[vertexIndex],\n            vertexArray[vertexIndex + 1],\n            vertexArray[vertexIndex + 2],\n            vertexArray[vertexIndex + 3],\n            vertexArray[vertexIndex + 4]\n          );\n        }\n        allVertices.push(\n          vertexArray[vertexIndex],\n          vertexArray[vertexIndex + 1],\n          vertexArray[vertexIndex + 2],\n          vertexArray[vertexIndex + 3],\n          vertexArray[vertexIndex + 4]\n        );\n      }\n    }\n\n    this.allVertices = allVertices;\n\n    const vertArray = new Float32Array(allVertices);\n    size = vertArray.BYTES_PER_ELEMENT;\n    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, size * 5, 0);\n    gl.enableVertexAttribArray(vertex);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = gl.getUniformLocation(program, 'matrix');\n    this.aPointSize = gl.getAttribLocation(program, 'pointSize');\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.uniformMatrix4fv(this.matrix, false, pixelsToWebGLMatrix);\n\n    this.attachShaderVariables(size);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.allVertices = [];\n    this.vertices = [];\n\n    const vertices = this.vertices\n      , settings = this.settings\n      , data = settings.data\n      , features = data.features\n      , map = settings.map\n      , latitudeKey = settings.latitudeKey\n      , longitudeKey = settings.longitudeKey\n      , featureMax = features.length\n      ;\n\n    let feature\n      , { color } = settings\n      , colorFn: (i: number, feature: any) => IColor\n      , chosenColor\n      , featureIndex = 0\n      ;\n\n    if (!color) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      //use colorFn function here if it exists\n      if (colorFn) {\n        chosenColor = colorFn(featureIndex, feature);\n      } else {\n        chosenColor = color as IColor;\n      }\n\n      const featureVertices = new LineFeatureVertices({\n        project: map.project.bind(map),\n        latitudeKey,\n        longitudeKey,\n        color: chosenColor,\n      });\n      featureVertices.fillFromCoordinates(feature.geometry.coordinates);\n      vertices.push(featureVertices);\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { gl, settings, canvas, mapMatrix, matrix, pixelsToWebGLMatrix, allVertices, vertices } = this\n      , weight = settings.weight\n      , { scale, offset, zoom } = e\n      , pointSize = Math.max(zoom - 4.0, 4.0)\n      ;\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.vertexAttrib1f(this.aPointSize, pointSize);\n    if (zoom > 18) {\n      mapMatrix\n        .set(pixelsToWebGLMatrix)\n        .scaleMatrix(scale)\n        .translateMatrix(-offset.x, -offset.y);\n      // -- attach matrix value to 'mapMatrix' uniform in shader\n      gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n\n      gl.drawArrays(gl.LINES, 0, allVertices.length / 5);\n    } else if (typeof weight === 'number') {\n      // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n      for (let yOffset = -weight; yOffset < weight; yOffset += 0.5) {\n        for (let xOffset = -weight; xOffset < weight; xOffset += 0.5) {\n          // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n          mapMatrix\n            .set(pixelsToWebGLMatrix)\n            .scaleMatrix(scale)\n            .translateMatrix(-offset.x + (xOffset / scale), -offset.y + (yOffset / scale));\n          // -- attach matrix value to 'mapMatrix' uniform in shader\n          gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n\n          gl.drawArrays(gl.LINES, 0, allVertices.length / 5);\n        }\n      }\n    } else if (typeof weight === 'function') {\n      let allVertexCount = 0;\n      const features = settings.data.features;\n      for (let i = 0; i < vertices.length; i++) {\n        const featureVertices = vertices[i];\n        const vertexCount = featureVertices.vertexCount;\n        const weightValue = weight(i, features[i]);\n        // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n        for (let yOffset = -weightValue; yOffset < weightValue; yOffset += 0.5) {\n          for (let xOffset = -weightValue; xOffset < weightValue; xOffset += 0.5) {\n            // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n            mapMatrix\n              .set(pixelsToWebGLMatrix)\n              .scaleMatrix(scale)\n              .translateMatrix(-offset.x + (xOffset / scale), -offset.y + (yOffset / scale));\n            // -- attach matrix value to 'mapMatrix' uniform in shader\n            gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n            gl.drawArrays(gl.LINES, allVertexCount, vertexCount);\n          }\n        }\n        allVertexCount += vertexCount;\n      }\n    }\n    return this;\n  }\n\n  static tryClick(e: LeafletMouseEvent, map: Map): void {\n    let foundFeature = false\n      , instance = null\n      , record = 0.1\n      , settings\n      ;\n    Lines.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      settings.data.features.map(feature => {\n        for (let i = 1; i < feature.geometry.coordinates.length; i++) {\n          let distance = pDistance(e.latlng.lng, e.latlng.lat,\n            feature.geometry.coordinates[i - 1][0], feature.geometry.coordinates[i - 1][1],\n            feature.geometry.coordinates[i][0], feature.geometry.coordinates[i][1]);\n          if (distance < record) {\n            record = distance;\n            foundFeature = feature;\n            instance = _instance;\n          }\n        }\n      });\n    });\n\n    if (instance) {\n      instance.settings.click(e, foundFeature);\n    } else {\n      return;\n    }\n  }\n}\n","import { Feature, Point as GeoPoint } from 'geojson';\n\nimport { Base, IBaseSettings } from './base';\nimport { ICanvasOverlayDrawEvent } from './canvas-overlay';\nimport { Color, IColor } from './color';\nimport { LeafletMouseEvent, Map, Point, LatLng, Projection } from './leaflet-bindings';\nimport { IPixel } from './pixel';\nimport { locationDistance, pointInCircle } from './utils';\n\nexport interface IPointsSettings extends IBaseSettings {\n  size: ((i: number, latLng: LatLng) => number) | number;\n  eachVertex?: (this: Points, latLng: LatLng, pixel: IPixel, color: IColor) => void;\n  sensitivity?: number;\n}\n\nconst defaults: IPointsSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  setupClick: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  eachVertex: null,\n  click: null,\n  color: Color.random,\n  opacity: 0.8,\n  size: null,\n  className: '',\n  sensitivity: 2,\n  shaderVariables: {\n    vertex: {\n      type: 'FLOAT',\n      start: 0,\n      size: 2,\n      bytes: 6\n    },\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 3,\n      bytes: 6\n    },\n    pointSize: {\n      type: 'FLOAT',\n      start: 5,\n      size: 1,\n      bytes: 6\n    },\n  }\n};\n\nexport interface IPointLookup {\n  latLng: LatLng;\n  pixel: IPixel;\n  chosenColor: IColor;\n  chosenSize: number;\n  key: string;\n  feature?: any;\n}\n\nexport class Points extends Base<IPointsSettings> {\n  static instances: Points[] = [];\n  static defaults = defaults;\n  static maps = [];\n  latLngLookup: {\n    [key: string]: IPointLookup[];\n  };\n  allLatLngLookup: IPointLookup[];\n  vertices: number[];\n  dataFormat: 'Array' | 'GeoJson.FeatureCollection';\n\n  constructor(settings) {\n    super(settings);\n    Points.instances.push(this);\n    this.settings = {...Points.defaults, ...settings};\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n\n    this.active = true;\n\n    const { data } = this.settings;\n    if (Array.isArray(data)) {\n      this.dataFormat = 'Array';\n    } else if (data.type === 'FeatureCollection') {\n      this.dataFormat = 'GeoJson.FeatureCollection';\n    } else {\n      throw new Error('unhandled data type. Supported types are Array and GeoJson.FeatureCollection');\n    }\n\n    // @ts-ignore\n    if (this.settings.map.options.crs.projection.project !== Projection.SphericalMercator.project) {\n      console.warn('layer designed for SphericalMercator, alternate detected');\n    }\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n\n    this.resetVertices();\n\n    //look up the locations for the inputs to our shaders.\n    const { gl, settings, canvas, program, layer, vertices, pixelsToWebGLMatrix } = this\n      , matrix = this.matrix = gl.getUniformLocation(program, 'matrix')\n      , opacity = gl.getUniformLocation(program, 'opacity')\n      , vertexBuffer = gl.createBuffer()\n      , vertexArray = new Float32Array(vertices)\n      , byteCount = vertexArray.BYTES_PER_ELEMENT\n      ;\n\n    //set the matrix to some that makes 1 unit 1 pixel.\n    pixelsToWebGLMatrix.set([\n      2 / canvas.width, 0, 0, 0,\n      0, -2 / canvas.height, 0, 0,\n      0, 0, 0, 0,\n      -1, 1, 0, 1\n    ]);\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, pixelsToWebGLMatrix);\n    gl.uniform1f(opacity, settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);\n\n    this.attachShaderVariables(byteCount);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices() {\n    //empty vertices and repopulate\n    this.latLngLookup = {};\n    this.allLatLngLookup = [];\n    this.vertices = [];\n\n    const { vertices, latLngLookup } = this\n      , { latitudeKey, longitudeKey, data, map, eachVertex } = this.settings\n      ;\n    let colorFn: (i: number, latLng: LatLng | any) => IColor\n      , { color, size } = this.settings\n      , chosenColor\n      , chosenSize\n      , sizeFn\n      , latLng\n      , pixel: Point\n      , key\n      ;\n\n    if (!color) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color as (i: number, latLng: LatLng) => IColor;\n    }\n\n    if (!size) {\n      throw new Error('size is not properly defined');\n    } else if (typeof size === 'function') {\n      sizeFn = size;\n    }\n\n    if (this.dataFormat === 'Array') {\n      const max = data.length;\n      for (let i = 0; i < max; i++) {\n        latLng = data[i];\n        key = latLng[latitudeKey].toFixed(2) + 'x' + latLng[longitudeKey].toFixed(2);\n        pixel = map.project(new LatLng(latLng[latitudeKey], latLng[longitudeKey]), 0);\n\n        if (colorFn) {\n          chosenColor = colorFn(i, latLng) as IColor;\n        } else {\n          chosenColor = color as IColor;\n        }\n\n        if (sizeFn) {\n          chosenSize = sizeFn(i, latLng) as number;\n        } else {\n          chosenSize = size as number;\n        }\n\n        //-- 2 coord, 3 rgb colors, 1 size interleaved buffer\n        vertices.push(pixel.x, pixel.y, chosenColor.r, chosenColor.g, chosenColor.b, chosenSize);\n\n        const lookup = { latLng, key, pixel, chosenColor, chosenSize };\n        (latLngLookup[key] || (latLngLookup[key] = []))\n          .push(lookup);\n        this.allLatLngLookup.push(lookup);\n        if (eachVertex) {\n          eachVertex.call(this, latLng, pixel, chosenSize);\n        }\n      }\n    } else if (this.dataFormat === 'GeoJson.FeatureCollection') {\n      const max = data.features.length;\n      for (let i = 0; i < max; i++) {\n        const feature = data.features[i] as Feature<GeoPoint>;\n        latLng = feature.geometry.coordinates;\n        key = latLng[latitudeKey].toFixed(2) + 'x' + latLng[longitudeKey].toFixed(2);\n        pixel = map.project(new LatLng(latLng[latitudeKey], latLng[longitudeKey]), 0);\n\n        if (colorFn) {\n          chosenColor = colorFn(i, feature) as IColor;\n        } else {\n          chosenColor = color as IColor;\n        }\n\n        if (sizeFn) {\n          chosenSize = sizeFn(i, latLng) as number;\n        } else {\n          chosenSize = size as number;\n        }\n\n        //-- 2 coord, 3 rgb colors, 1 size interleaved buffer\n        vertices.push(pixel.x, pixel.y, chosenColor.r, chosenColor.g, chosenColor.b, chosenSize);\n\n        const lookup = { latLng, key, pixel, chosenColor, chosenSize, feature, };\n        (latLngLookup[key] || (latLngLookup[key] = []))\n          .push(lookup);\n        this.allLatLngLookup.push(lookup);\n        if (eachVertex) {\n          eachVertex.call(this, latLng, pixel, chosenSize);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  pointSize(pointIndex): number {\n    const { map, size } = this.settings\n      , pointSize = typeof size === 'function' ? size(pointIndex, null) : size\n      // -- Scale to current zoom\n      , zoom = map.getZoom()\n      ;\n\n    return pointSize === null ? Math.max(zoom - 4.0, 1.0) : pointSize;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { gl, canvas, settings, mapMatrix, matrix, pixelsToWebGLMatrix, vertices } = this\n      , map = settings.map\n      , { offset } = e\n      , zoom = map.getZoom()\n      , scale = Math.pow(2, zoom)\n      ;\n\n    pixelsToWebGLMatrix.set([\n      2 / canvas.width, 0, 0, 0,\n      0, -2 / canvas.height, 0, 0,\n      0, 0, 0, 0,\n      -1, 1, 0, 1\n    ]);\n\n    //set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .set(pixelsToWebGLMatrix)\n      .scaleMatrix(scale)\n      .translateMatrix(-offset.x, -offset.y);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n    gl.drawArrays(gl.POINTS, 0, vertices.length / 6);\n\n    return this;\n  }\n\n  lookup(coords: LatLng): IPointLookup {\n    const xMax: number = coords.lat + 0.03\n      , yMax: number = coords.lng + 0.03\n      , matches: IPointLookup[] = []\n      ;\n    let x = coords.lat - 0.03\n      , y: number\n      , foundI: number\n      , foundMax: number\n      , found: IPointLookup[]\n      , key: string\n      ;\n\n    for (; x <= xMax; x += 0.01) {\n      y = coords.lng - 0.03;\n      for (; y <= yMax; y += 0.01) {\n        key = x.toFixed(2) + 'x' + y.toFixed(2);\n        found = this.latLngLookup[key];\n        if (found) {\n          foundI = 0;\n          foundMax = found.length;\n          for (; foundI < foundMax; foundI++) {\n            matches.push(found[foundI]);\n          }\n        }\n      }\n    }\n\n    const { map } = this.settings;\n\n    //try matches first, if it is empty, try the data, and hope it isn't too big\n    return Points.closest(\n      coords,\n      matches.length > 0\n        ? matches\n        : this.allLatLngLookup,\n      map\n    );\n  }\n\n  static closest(targetLocation: LatLng, points: IPointLookup[], map: Map): IPointLookup {\n    if (points.length < 1) return null;\n    return points.reduce((prev, curr) => {\n      const prevDistance = locationDistance(targetLocation, prev.latLng, map)\n        , currDistance = locationDistance(targetLocation, curr.latLng, map)\n        ;\n      return (prevDistance < currDistance) ? prev : curr;\n    });\n  }\n\n  static tryClick(e: LeafletMouseEvent, map: Map): boolean | void {\n    const closestFromEach: IPointLookup[] = []\n      , instancesLookup = {}\n      ;\n    let result\n      , settings: IPointsSettings\n      , instance: Points\n      , pointLookup: IPointLookup\n      , xy: Point\n      , found: IPointLookup\n      , foundLatLng\n      ;\n\n    Points.instances.forEach((_instance) => {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      pointLookup = _instance.lookup(e.latlng);\n      instancesLookup[pointLookup.key] = _instance;\n      closestFromEach.push(pointLookup);\n    });\n\n    if (closestFromEach.length < 1) return;\n    if (!settings) return;\n\n    found = this.closest(e.latlng, closestFromEach, map);\n\n    if (found === null) return;\n\n    instance = instancesLookup[found.key];\n    if (!instance) return;\n    const { latitudeKey, longitudeKey, sensitivity, click } = instance.settings;\n\n    foundLatLng = new LatLng(found.latLng[latitudeKey], found.latLng[longitudeKey]);\n    xy = map.latLngToLayerPoint(foundLatLng);\n\n    if (pointInCircle(\n      xy,\n      e.layerPoint,\n      found.chosenSize * sensitivity\n    )) {\n      result = click(e, found.feature || found.latLng, xy);\n      return result !== undefined ? result : true;\n    }\n  }\n}\n","import earcut from 'earcut';\nimport geojsonFlatten from 'geojson-flatten';\nimport PolygonLookup from 'polygon-lookup';\n\nimport { Base, IBaseSettings } from './base';\nimport { ICanvasOverlayDrawEvent } from './canvas-overlay';\nimport { Color, IColor } from './color';\nimport { LatLng, LeafletMouseEvent, Map, Point } from './leaflet-bindings';\n\nexport interface IShapeSettings extends IBaseSettings {}\n\nexport const defaults: IShapeSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  setupClick: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  click: null,\n  color: Color.random,\n  className: '',\n  opacity: 0.5,\n  shaderVariables: {\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 3\n    }\n  }\n};\n\nexport class Shapes extends Base<IShapeSettings> {\n  static instances: Shapes[] = [];\n  static defaults = defaults;\n  static maps: Map[];\n  polygonLookup: PolygonLookup;\n\n  constructor(settings: IShapeSettings) {\n    super(settings);\n    Shapes.instances.push(this);\n    this.settings = { ...Shapes.defaults, ...settings };\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n    this.polygonLookup = null;\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n    // triangles or point count\n\n    const { pixelsToWebGLMatrix, settings, canvas, gl, layer, vertices, program } = this\n      , vertexBuffer = gl.createBuffer()\n      , vertArray = new Float32Array(vertices)\n      , byteCount = vertArray.BYTES_PER_ELEMENT\n      , vertex = gl.getAttribLocation(program, 'vertex')\n      , opacity = gl.getUniformLocation(program, 'opacity')\n      ;\n    gl.uniform1f(opacity, settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, byteCount * 5, 0);\n    gl.enableVertexAttribArray(vertex);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = gl.getUniformLocation(program, 'matrix');\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.uniformMatrix4fv(this.matrix, false, pixelsToWebGLMatrix);\n\n    this.attachShaderVariables(byteCount);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.vertices = [];\n    this.polygonLookup = new PolygonLookup();\n\n    const { vertices, polygonLookup, settings } = this\n      , data = settings.data as any\n      ;\n\n    let pixel\n      , index\n      , features\n      , feature\n      , { color } = settings\n      , colorFn: (i: number, feature: any) => IColor\n      , chosenColor: IColor\n      , coordinates\n      , featureIndex = 0\n      , featureMax\n      , triangles\n      , indices\n      , flat\n      , dim\n      ;\n\n    switch (data.type) {\n      case 'Feature':\n        polygonLookup.loadFeatureCollection({\n          type: 'FeatureCollection',\n          features: [data]\n        });\n        features = geojsonFlatten(data);\n        break;\n      case 'MultiPolygon':\n        polygonLookup.loadFeatureCollection({\n          type: 'FeatureCollection',\n          features: [{\n            type: 'Feature',\n            properties: { id: 'bar' },\n            geometry: { coordinates: data.coordinates }\n          }]\n        });\n        features = geojsonFlatten(data);\n        break;\n      default:\n        polygonLookup.loadFeatureCollection(data);\n        features = data.features;\n    }\n    featureMax = features.length;\n\n    if (!color) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      triangles = [];\n\n      //use colorFn function here if it exists\n      if (colorFn) {\n        chosenColor = colorFn(featureIndex, feature);\n      } else {\n        chosenColor = color as IColor;\n      }\n\n      coordinates = (feature.geometry || feature).coordinates;\n      flat = earcut.flatten(coordinates);\n      indices = earcut(flat.vertices, flat.holes, flat.dimensions);\n      dim = coordinates[0][0].length;\n      for (let i = 0, iMax = indices.length; i < iMax; i++) {\n        index = indices[i];\n        if (typeof flat.vertices[0] === 'number') {\n          triangles.push(flat.vertices[index * dim + settings.longitudeKey], flat.vertices[index * dim + settings.latitudeKey]);\n        } else {\n          throw new Error('unhandled polygon');\n        }\n      }\n\n      for (let i = 0, iMax = triangles.length; i < iMax; i) {\n        pixel = settings.map.project(new LatLng(triangles[i++], triangles[i++]), 0);\n        vertices.push(pixel.x, pixel.y, chosenColor.r, chosenColor.g, chosenColor.b);\n      }\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { scale, offset, canvas } = e\n      , mapMatrix = this.mapMatrix\n      , pixelsToWebGLMatrix = this.pixelsToWebGLMatrix\n      ;\n\n    pixelsToWebGLMatrix.set([\n      2 / canvas.width, 0, 0, 0,\n      0, -2 / canvas.height, 0, 0,\n      0, 0, 0, 0,\n      -1, 1, 0, 1\n    ]);\n\n    // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .set(pixelsToWebGLMatrix)\n      .scaleMatrix(scale)\n      .translateMatrix(-offset.x, -offset.y);\n\n    const gl = this.gl;\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    // -- attach matrix value to 'mapMatrix' uniform in shader\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n    gl.drawArrays(gl.TRIANGLES, 0, this.vertices.length / 5);\n\n    return this;\n  }\n\n  static tryClick(e: LeafletMouseEvent, map: Map): boolean {\n    let result\n      , settings\n      , feature\n      ;\n\n    Shapes.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      feature = _instance.polygonLookup.search(e.latlng.lng, e.latlng.lat);\n      if (feature) {\n        result = settings.click(e, feature);\n      }\n    });\n\n    return result !== undefined ? result : true;\n  }\n}\n","import { LeafletMouseEvent, Map } from './leaflet-bindings';\n\nimport { Lines, ILinesSettings } from './lines';\nimport { MapMatrix } from './map-matrix';\nimport { Points, IPointsSettings } from './points';\nimport { IShapeSettings, Shapes } from './shapes';\n\n// @ts-ignore\nimport vertex from './shader/vertex/default.glsl';\n// @ts-ignore\nimport dot from './shader/fragment/dot.glsl';\n// @ts-ignore\nimport point from './shader/fragment/point.glsl';\n// @ts-ignore\nimport puck from './shader/fragment/puck.glsl';\n// @ts-ignore\nimport simpleCircle from './shader/fragment/simple-circle.glsl';\n// @ts-ignore\nimport square from './shader/fragment/square.glsl';\n// @ts-ignore\nimport polygon from './shader/fragment/polygon.glsl';\n\nconst shader = {\n  vertex,\n  fragment: {\n    dot,\n    point,\n    puck,\n    simpleCircle,\n    square,\n    polygon,\n  }\n};\n\nclass Glify {\n  longitudeKey: number = 1;\n  latitudeKey: number = 0;\n  maps: Map[] = [];\n  shader = shader;\n\n  Points: typeof Points = Points;\n  Shapes: typeof Shapes = Shapes;\n  Lines: typeof Lines = Lines;\n\n  longitudeFirst(): this {\n    this.longitudeKey = 0;\n    this.latitudeKey = 1;\n    return this;\n  }\n\n  latitudeFirst(): this {\n    this.latitudeKey = 0;\n    this.longitudeKey = 1;\n    return this;\n  }\n\n  get instances() {\n    return [\n      ...Points.instances,\n      ...Lines.instances,\n      ...Shapes.instances,\n    ];\n  }\n\n  points(settings: IPointsSettings): Points {\n    return new this.Points({\n      setupClick: glify.setupClick.bind(this),\n      latitudeKey: glify.latitudeKey,\n      longitudeKey: glify.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.point;\n      },\n      ...settings,\n    });\n  }\n\n  shapes(settings: IShapeSettings): Shapes {\n    return new this.Shapes({\n      setupClick: this.setupClick.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      ...settings\n    });\n  }\n\n  lines(settings: ILinesSettings): Lines {\n    return new this.Lines({\n      setupClick: this.setupClick.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      ...settings\n    });\n  }\n\n  setupClick(map?: Map): void {\n    if (this.maps.indexOf(map) < 0) {\n      this.maps.push(map);\n      map.on('click', (e: LeafletMouseEvent) => {\n        let hit;\n        hit = Points.tryClick(e, map);\n        if (hit !== undefined) return hit;\n\n        hit = Lines.tryClick(e, map);\n        if (hit !== undefined) return hit;\n\n        hit = Shapes.tryClick(e, map);\n        if (hit !== undefined) return hit;\n      });\n    }\n  }\n}\n\nconst glify = new Glify();\nexport default module.exports = glify;\nif (typeof window !== 'undefined' && window.L) {\n  // @ts-ignore\n  window['L'].glify = glify;\n  // @ts-ignore\n  window['L'].Glify = Glify;\n}"]}